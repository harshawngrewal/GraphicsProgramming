Basics:
 - 3 steps in preparing a frame: 1. vertex shading, rasterization, fragment shading
 - vertex shading is the preparation of triangles/vertices. This is done by the gpu for every single object inside the frame. The end result are vertices with a x,y,z coordinate for the view screen. Note that this is not enough the display the frame as we need to do more processing of the framebuffer(lighting, converting to 2d image, etc). This step is more so called the graphics pipeline
 	- a substep is called geometry shading which does more transformations
 - primitive assembly - takes the output from previous steps and assembles the points to form one or more primitives(eg. a triangle)
 - rasterization takes the trigangles from previous steps to map to triangles generated by the graphics pipeline and map it to the correct pixels of a screen. Transforming triangles -> fragmenets
 - last steps is fragmenet shading. This including things like anti aliasing, lighting(which account for pixel blurring due to triangles taking up part of a pixel, so we want to shade the pixel to reduce blurring)
 
 Linear Algebra:
 - mostly going to be taking physical notes for this
 
OpenGL:
- This is apparently this most user friendly api for graphics programming
- It is a spec meaning the implemention is on the gpu provider
- https://learnopengl.com

pm4 packets:
- when umd prepares submission buffers, those submission buffers are populated with pm4 cmds
- this spec is decided by the gpu vendor but involve packets to dispatch a draw, write fence, synchornization

shader:
- written in HLSL and it compiled to sp3 microcode?
- for opengl is GLSL - opengl shading language
- this is code that is acutally run on the cores in what we call waves
- this is the dispatch draw????
- example of shaders include pixel shaders, texture shaders, etc
- on a hardware level these shaders are prob broken down into many different threads and waves and launched on various gpu cores

GLFW : 
- C lib required to create a opengl context and display a sample window, and processing user input
- opengl lib
- also provides calls to process user inputs, which is something that opengl doesn't do out of the box

GLAD:
- the opengl functions can't be linked at complile time. They will be called on at runtime
- basically it isn't a libarary or something which can be statically or dynamically linked
- We have to store the function pointers that we want to call on and  then find those functions at runtime with the call wglGetProcAddress('function name')
- GLAD is kind of a wrapper library which abstracts away the opengl function calls. We can call on these functions instead and not worry about finding the correct opengl function
- add glad.c to your project and add the header to your include directory so that they can be used by any project

double buffer technique:
-"Double buffer
When an application draws in a single buffer the resulting image may display flickering issues. This is because the resulting output image is not drawn in an instant, but drawn pixel by pixel and usually from left to right and top to bottom. Because this image is not displayed at an instant to the user while still being rendered to, the result may contain artifacts. To circumvent these issues, windowing applications apply a double buffer for rendering. The front buffer contains the final output image that is shown at the screen, while all the rendering commands draw to the back buffer. As soon as all the rendering commands are finished we swap the back buffer to the front buffer so the image can be displayed without still being rendered to, removing all the aforementioned artifacts. "
check opengl version
- glxinfo | grep "OpenGL version"

frame: 
- this is 2d array of pixels. It is the job of the gpu including opengl to transform 3d images into 2d

graphics pipeline:
- process of converting 3d coordinates into 2d array of pixels
- vertex shader - geometry shader - shape assembly - tests and blending - framgent shader - rasterization
- we pass in the vertex data into the shader which is a collection of vertices((x,y,z))

primitives:
- are hints given to opengl on how to draw a set of verticies onto the screen?
- for example should they form a triangle, line, etc
- GL_POINTS, GL_TRIANGLES and GL_LINE_STRIP

viewport transform:
- remember that the coordinates we provide are normalized, they need to be correctly transformed into screen space coordinates that we provided by glViewport.

vertex input:
- as a programmer we have to specify the vertex shader and fragement shader. There are default for the other steps in the graphics pipeline so  that we don't have to handle it
- range for each coordinate is -1, 1 called normalized device coordinates
- stored in vertex buffer objects

vertex array object:
- when we have multiple different vertex/fragmenet shaders for each vertex attribute
- if we want to process a configure a different attribute we have to re-run some steps(bindbufffer, buffer copy, set vertex attribute, draw)
- instead we can set something called VAO which is an array that points  to different attributes and vertex objects. 

Allocating buffer:
- different types of object(buffers, textures, etc)
- First we specify a buffer by assigning an object (genbuffers)
- This will assign our object to a buffer type(just an enum)
- Then we bind the buffer to a target using bindbuffers
- This just specifies the type of buffer (eg. GL_ARRAY_BUFFER)
- This target provides an interface to handle the buffer
- Any buffer calls on the target will be used to configure the currently binded target,

vertex shader:
- written in GLSL compiled and then can be linked to our application
- needs to be prepared by programmer(no default)
- in shader we need to declare the version of GLSL
- declare all the attributes for the input vertices for the shader

fragment shader:
- after the coordinate transformation done by vertex shader, we need to color the pixels

final shader:
- at runtime, after both vertex and fragment shader are compiled
- we need to link them into final shader so that we can run them easily whenever we want


Cmake: 
- mkdir build, cd build, cmake ..

