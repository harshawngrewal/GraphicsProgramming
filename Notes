Basics:
 - 3 steps in preparing a frame: 1. vertex shading, rasterization, fragment shading
 - vertex shading is the preparation of triangles/vertices. This is done by the gpu for every single object inside the frame. The end result are vertices with a x,y,z coordinate for the view screen. Note that this is not enough the display the frame as we need to do more processing of the framebuffer(lighting, converting to 2d image, etc). This step is more so called the graphics pipeline
 - rasterization takes the trigangles from previous steps to map to triangles generated by the graphics pipeline and map it to the correct pixels of a screen. Transforming triangles -> fragmenets
 - last steps is fragmenet shading. This including things like anti aliasing, lighting(which account for pixel blurring due to triangles taking up part of a pixel, so we want to shade the pixel to reduce blurring)
 
 Linear Algebra:
 - mostly going to be taking physical notes for this
 
OpenGL:
- This is apparently this most user friendly api for graphics programming
- It is a spec meaning the implemention is on the gpu provider

GLFW : 
- C lib required to create a opengl context and display a sample window, and processing user input

GLAD:
- the opengl functions can't be linked at complile time. They will be called on at runtime
- basically it isn't a libarary or something which can be statically or dynamically linked
- We have to store the function pointers that we want to call on and  then find those functions at runtime with the call wglGetProcAddress('function name')
- GLAD is kind of a wrapper library which abstracts away the opengl function calls. We can call on these functions instead and not worry about finding the correct opengl function
- add glad.c to your project and add the header to your include directory so that they can be used by any project

Cmake: 
- mkdir build, cd build, cmake ..

